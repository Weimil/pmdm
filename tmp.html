<header>
    <h1>Making maps with noise functions</h1>
    <div class="subheading">
        from <a href="https://www.redblobgames.com/">Red Blob Games</a></div>
    <nav>
        <form action="https://www.google.com/search">
            <ul>
                <li><a href="https://www.redblobgames.com/">Home</a></li>
                <li><a href="//simblob.blogspot.com/">Blog</a></li>
                <li><a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li>
                <li><a href="https://twitter.com/redblobgames">Twitter</a></li>
                <li><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li>
                <li>&nbsp;</li>
                <li><input type="search" name="q" placeholder="Search" size="8"></li>
            </ul><input type="hidden" name="hq"
                value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com">
        </form>
    </nav>
</header>
<main>
    <address>written Jul 2015, then updated Feb 2016, May 2017, Oct 2017, Jan 2018, Feb 2019, Jun 2019, Mar 2020, May
        2020</address>
    <div id="table-of-contents">
        <h2>Table of Contents</h2>
        <div id="text-table-of-contents">
            <ul>
                <li><a href="#noise">Noise</a></li>
                <li><a href="#elevation">Elevation</a></li>
                <li><a href="#biomes">Biomes</a></li>
                <li><a href="#climate">Climate</a></li>
                <li><a href="#islands">Islands</a></li>
                <li><a href="#ridged">Ridges</a></li>
                <li><a href="#terraces">Terraces</a></li>
                <li><a href="#trees">Trees</a></li>
                <li><a href="#wraparound">Wraparound map</a></li>
                <li><a href="#infinite">Infinite map</a></li>
                <li><a href="#implementation">Implementation</a></li>
                <li><a href="#demo">Demo</a></li>
                <li><a href="#thoughts">Thoughts</a></li>
                <li><a href="#more">More</a></li>
            </ul>
        </div>
    </div>
    <section>
        <p>One of the more popular pages on my site is about <a
                href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">polygonal map
                generation</a><sup class="print-endnote">[1]</sup>. Making those maps was a lot of work. I didn’t start
            there. I started with something <em>much</em> simpler, which I’ll describe here. The simpler technique can
            make maps like this in under 50 lines of code:</p>
        <figure class="img-1"><img src="images/topdemo-3d.png?2021-10-15-20-01-58" width="600" height="300"></figure>
        <p>I’m not going to explain how to <em>draw</em> these maps; that’s going to depend on your language, graphics
            library, platform, etc. I’m only going to explain how to <em>fill an array</em> with height and biome map
            data.</p>
    </section>
    <section>
        <h2 id="noise"><span><a href="#noise">Noise</a></span><a class="anchor" href="#noise">#</a></h2>
        <p>A common way to generate 2D maps is to use a bandwidth-limited noise function, such as Simplex or Perlin
            noise, as a building block. This is what the noise function looks like:</p>
        <figure class="img-1"><img src="images/render-noise.png?2021-10-15-20-01-47" width="600" height="200"></figure>
        <p>We assign each location on the map a number from 0.0 to 1.0. In this image, 0.0 is black and 1.0 is white.
            Here’s how to set the color at each grid location in C-like syntax:</p>
        <pre>for (int y = 0; y &lt; height; y++) {
for (int x = 0; x &lt; width; x++) {      
double nx = x/width - 0.5, ny = y/height - 0.5;
<b>value[y][x] = noise(nx, ny);</b>
}
}</pre>
        <p>The loop will work the same in Javascript, Python, Haxe, C++, C#, Java, and most other popular languages, so
            I’ll show it in C-like syntax and you can convert it to the language you’re using. In the rest of the
            tutorial, I’ll show how the loop body (the <code>value[y][x]=…</code> line) changes as we add more features.
            At <a href="#demo">the end</a>, I’ll show a complete example.</p>
        <p>Depending on the library you use, you may have to shift or multiply the values you get back to fit into the
            0.0 to 1.0 range. Some libraries return 0.0 to 1.0; some return -1.0 to +1.0; some return other ranges like
            -0.7 to +0.7. Some don’t say what they return, so you may have to look at the return values to figure out
            the range.</p>
    </section>
    <section>
        <h2 id="elevation"><span><a href="#elevation">Elevation</a></span><a class="anchor" href="#elevation">#</a></h2>
        <p>Noise by itself is just a bunch of numbers. We need to assign <em>meaning</em> to it. The first thing we
            might think of is to make the noise correspond to elevation (also called a “height map”). Let’s take the
            noise from earlier and draw it as elevation:</p>
        <figure class="img-2"><img src="images/render-elevation-2d.png?2021-10-15-20-01-46" width="300"
                height="200"><img src="images/render-elevation-3d.png?2021-10-15-20-01-48" width="300" height="200">
        </figure>
        <p>The code is almost the same, except for what’s inside the inner loop; it now looks like this:</p>
        <pre><b>elevation</b>[y][x] = noise(nx, ny);</pre>
        <p>Yes, that’s it. The map data is the same, but now I call it <code>elevation</code> instead of
            <code>value</code>.</p>
        <p>Lots of hills, but not much else. What’s wrong?</p>
        <h3><span>Frequency</span></h3>
        <p>Noise can be generated at any <em>frequency</em>. I’ve only picked one frequency so far. Let’s look at the
            effect of frequency. <strong>Try moving the slider</strong> to see what happens at different frequencies:
        </p>
        <figure class="img-2"><img src="images/render-noise-frequency-2d.png?2021-10-15-20-01-46" width="300"
                height="200"><img src="images/render-noise-frequency-3d.png?2021-10-15-20-01-48" width="300"
                height="200"><br> frequency=<input id="noise-frequency" type="range" min="1" max="7" step="0.01"
                value="2" list="noise-frequency-settings"><datalist id="noise-frequency-settings">
                <option>2</option>
            </datalist></figure>
        <p>It’s just zooming in and out. That doesn’t seem very useful at first glance, but it is.</p>
        <pre>elevation[y][x] = noise(<b><span class="noise-frequency">frequency</span> * </b>nx, <b><span class="noise-frequency">frequency</span> * </b>ny);</pre>
        <p>It’s sometimes useful to think of <em>wavelength</em>, which is the inverse of frequency. Frequency is
            measured in oscillations per distance. Doubling the frequency makes everything half the size. Wavelength is
            measured in distance per oscillation, measured in pixels or tiles or meters etc. Doubling the wavelength
            makes everything twice the size. Wavelength is related to frequency:
            <code>wavelength = map_size / frequency</code>.</p>
        <pre>elevation[y][x] = noise(x<b> / <span class="noise-wavelength">wavelength</span></b>, y<b> / <span class="noise-wavelength">wavelength</span></b>);</pre>
        <p>I have <a href="/articles/noise/introduction.html">another tutorial</a> that explains the <em>concepts</em>:
            frequency, wavelength, amplitude, octaves, pink and blue and white noise, etc.</p>
        <h3><span>Octaves</span></h3>
        <p>To make the height map more interesting we’re going <em>add noise at different frequencies</em>:</p>
        <figure
            style="font-size:36px;font-weight:bold;display:grid;grid-template-columns:1fr repeat(3, 2ch 1fr);align-items:center;justify-items:center">
            <img src="images/render-addition-1.png?2021-10-15-20-01-48" width="100%"><span>&nbsp;+&nbsp;</span><img
                src="images/render-addition-2.png?2021-10-15-20-01-47" width="100%"><span>&nbsp;+&nbsp;</span><img
                src="images/render-addition-3.png?2021-10-15-20-01-47" width="100%"><span>&nbsp;=&nbsp;</span><img
                src="images/render-addition-sum.png?2021-10-15-20-01-50" width="100%"></figure>
        <pre>elevation[y][x] = <b>   1 *</b> noise(<b>1 *</b> nx, <b>1 *</b> ny);
    + <b> 0.5 *</b> noise(<b>2 *</b> nx, <b>2 *</b> ny);
    + <b>0.25 *</b> noise(<b>4 *</b> nx, <b>4 *</b> ny);</pre>
        <p>Let’s mix big low frequency hills and small high frequency hills into the same map. <strong>Move the
                slider</strong> to add smaller hills to the mix:</p>
        <figure class="img-2"><img src="images/render-noise-fbm-2d.png?2021-10-15-20-01-48" width="300"
                height="200"><img src="images/render-noise-fbm-3d.png?2021-10-15-20-01-50" width="300"
                height="200"><br><input id="noise-fbm-mix" type="range" min="0" max="1" step="0.01" value="0"
                list="noise-fbm-settings"><datalist id="noise-fbm-settings">
                <option>0.0</option>
                <option>0.5</option>
            </datalist></figure>
        <p>Now that looks a lot more like the fractal terrain we want! We can now get hills and rugged mountains, but we
            still don’t get flat valleys. We need something else for that.</p>
        <p>There’s a potential problem though. Since <code>noise</code> can go from 0 to 1, the sum
            <code>1 * noise() + 0.5 * noise() + 0.25 * noise()</code> can go from 0 to 1.75. The numbers 1, 0.5, 0.25
            are called the <em>amplitudes</em>. The simplest thing to do is to divide by the sum of amplitudes:</p>
        <pre>             e  =    1 * noise(1 * nx, 1 * ny);
    +  0.5 * noise(2 * nx, 2 * ny);
    + 0.25 * noise(4 * nx, 4 * ny);
elevation[y][x] = <b>e / (1 + 0.5 + 0.25)</b>;</pre>
        <p>In practice, you may want to experiment to find the best divisor. Although the sum of amplitudes guarantees
            the elevation stays in the range 0–1, the elevation values may not be distributed the way you want.</p>
        <p>Another possible issue: by using <code>noise(1 * nx, 1 * ny)</code> and <code>noise(2 * nx, 2 * ny)</code>
            and <code>noise(4 * nx, 4 * ny)</code>, what happens when nx and ny are near 0? These noise values are
            <em>correlated</em>. To get the best results we want these to be <em>independent</em>. If your noise library
            allows seeding, you can use separate seeds for each of the octaves. If it does not allow seeding, you can
            add an offset to each of the octaves, such as <code>noise(1 * nx, 1 * ny)</code> and
            <code>noise(2 * nx + 5.3, 2 * ny + 9.1)</code> and <code>noise(4 * nx + 17.8, 4 * ny + 23.5)</code>. That
            way each octave is sampling from different parts of the noise space and they will be independent instead of
            correlated. And yet another possible issue: these noise values may be aligned along the same directions,
            which can sometimes cause visible artifacts, especially when using Perlin noise. To reduce this, rotate the
            output of some of the octaves, or switch to Simplex noise.</p>
        <!--
<p>
<a href="https://twitter.com/matthen2/status/1263108510541164544">Matt Henderson has a nice animation of adding octaves together</a>.
</p>
-->
        <h3><span>Redistribution</span></h3>
        <p>The noise function gives us values between 0 and 1. To make flat valleys, we can <em>raise the elevation to a
                power</em>. <strong>Move the slider</strong> to try different exponents.</p>
        <figure>
            <div style="display:grid;gap:50px;grid-template-columns:1fr 2fr;align-items:end"><svg
                    viewBox="-0.11 -0.01 1.12 1.12">
                    <path fill="none" stroke="#ccc" stroke-width="0.007" d="M 0,0 l 0,1 l 1,0 M 0,1 l 1,-1"></path>
                    <g fill="#999" font-size="0.1" text-anchor="middle" transform="translate(0,1)"><text x="0.03"
                            y="0.1">0</text><text x="0.97" y="0.1">1</text><text x="0.5" y="0.1">Before</text>
                        <g transform="rotate(-90) translate(0,-0.02)"><text x="0.03" y="0">0</text><text x="0.97"
                                y="0">1</text><text x="0.5" y="0">After</text></g>
                    </g>
                    <path id="render-exponent-line" fill="none" stroke="#a44" stroke-width="0.02" stroke-linecap="round"
                        transform="translate(0,1), scale(1,-1)"
                        d="M 0 0 L 0.0000 0.0000 L 0.0100 0.0100 L 0.0200 0.0200 L 0.0300 0.0300 L 0.0400 0.0400 L 0.0500 0.0500 L 0.0600 0.0600 L 0.0700 0.0700 L 0.0800 0.0800 L 0.0900 0.0900 L 0.1000 0.1000 L 0.1100 0.1100 L 0.1200 0.1200 L 0.1300 0.1300 L 0.1400 0.1400 L 0.1500 0.1500 L 0.1600 0.1600 L 0.1700 0.1700 L 0.1800 0.1800 L 0.1900 0.1900 L 0.2000 0.2000 L 0.2100 0.2100 L 0.2200 0.2200 L 0.2300 0.2300 L 0.2400 0.2400 L 0.2500 0.2500 L 0.2600 0.2600 L 0.2700 0.2700 L 0.2800 0.2800 L 0.2900 0.2900 L 0.3000 0.3000 L 0.3100 0.3100 L 0.3200 0.3200 L 0.3300 0.3300 L 0.3400 0.3400 L 0.3500 0.3500 L 0.3600 0.3600 L 0.3700 0.3700 L 0.3800 0.3800 L 0.3900 0.3900 L 0.4000 0.4000 L 0.4100 0.4100 L 0.4200 0.4200 L 0.4300 0.4300 L 0.4400 0.4400 L 0.4500 0.4500 L 0.4600 0.4600 L 0.4700 0.4700 L 0.4800 0.4800 L 0.4900 0.4900 L 0.5000 0.5000 L 0.5100 0.5100 L 0.5200 0.5200 L 0.5300 0.5300 L 0.5400 0.5400 L 0.5500 0.5500 L 0.5600 0.5600 L 0.5700 0.5700 L 0.5800 0.5800 L 0.5900 0.5900 L 0.6000 0.6000 L 0.6100 0.6100 L 0.6200 0.6200 L 0.6300 0.6300 L 0.6400 0.6400 L 0.6500 0.6500 L 0.6600 0.6600 L 0.6700 0.6700 L 0.6800 0.6800 L 0.6900 0.6900 L 0.7000 0.7000 L 0.7100 0.7100 L 0.7200 0.7200 L 0.7300 0.7300 L 0.7400 0.7400 L 0.7500 0.7500 L 0.7600 0.7600 L 0.7700 0.7700 L 0.7800 0.7800 L 0.7900 0.7900 L 0.8000 0.8000 L 0.8100 0.8100 L 0.8200 0.8200 L 0.8300 0.8300 L 0.8400 0.8400 L 0.8500 0.8500 L 0.8600 0.8600 L 0.8700 0.8700 L 0.8800 0.8800 L 0.8900 0.8900 L 0.9000 0.9000 L 0.9100 0.9100 L 0.9200 0.9200 L 0.9300 0.9300 L 0.9400 0.9400 L 0.9500 0.9500 L 0.9600 0.9600 L 0.9700 0.9700 L 0.9800 0.9800 L 0.9900 0.9900">
                    </path>
                </svg><img src="images/render-exponent-3d.png?2021-10-15-20-01-51" style="width:100%;height:auto"
                    width="300" height="200"></div> exp=<input id="noise-exponent" type="range" min="0.01" max="10"
                step="0.01" value="1" list="noise-exponent-settings"><datalist id="noise-exponent-settings">
                <option>1</option>
                <option>3</option>
                <option>5</option>
            </datalist>
        </figure>
        <pre>e =    1 * noise(1 * nx, 1 * ny);
+  0.5 * noise(2 * nx, 2 * ny);
+ 0.25 * noise(4 * nx, 4 * ny);
e = e / (1 + 0.5 + 0.25);
elevation[y][x] = <b>Math.pow(</b>e<b>, <span class="noise-exponent">exponent</span>)</b>;</pre>
        <p>Higher values <em>push middle elevations down into valleys</em> and lower values pull middle elevations up
            towards mountain peaks. We want to push them down. I use power functions here because they’re simple, but
            you can use any curve you want; I have a fancier demo <a href="/articles/noise/2d/#spectrum">here</a>.</p>
        <p>In practice it may work better to use <code>Math.pow(e * fudge_factor, exponent)</code>, where the fudge
            factor is some number near 1. For the above demo I used 1.2. Try different values and see what works best
            for you.</p>
        <p>The <em>pow()</em> function is only one way to reshape the elevations. There are many other functions you can
            try. You aren’t limited to mathematical functions; consider drawing curves yourself, like the “curves” tool
            in a photo editor.</p>
        <p>Now that we have a reasonable elevation map, let’s add some biomes!</p>
    </section>
    <section>
        <h2 id="biomes"><span><a href="#biomes">Biomes</a></span><a class="anchor" href="#biomes">#</a></h2>
        <p>Noise gives us numbers but we want a map with forests, deserts, and oceans. The first thing to do is to make
            low elevations into water:</p>
        <figure class="img-2"><img src="images/render-waterlevel-2d.png?2021-10-15-20-01-49" width="300"
                height="200"><img src="images/render-waterlevel-3d.png?2021-10-15-20-01-51" width="300"
                height="200"><br>water=<input id="waterlevel" type="range" min="0" max="1" step="0.01" value="0"
                list="waterlevel-settings"><datalist id="waterlevel-settings">
                <option>0.0</option>
                <option>0.1</option>
                <option>0.2</option>
                <option>0.5</option>
            </datalist></figure>
        <pre>function biome(e) {
if (e &lt; <span class="waterlevel">waterlevel</span>) return WATER;
else return LAND;
}</pre>
        <p>Hey, that’s starting to look like a procedurally generated world! We have water, grass, and snow. What if we
            want more things? Let’s make the sequence water, beach, grassland, forest, savannah, desert, snow:</p>
        <figure class="img-2"><img src="images/render-terrainbands-2d.png?2021-10-15-20-01-53" width="300"
                height="200"><img src="images/render-terrainbands-3d.png?2021-10-15-20-01-52" width="300" height="200">
            <figcaption>Terrain based on elevation only</figcaption>
        </figure>
        <pre>function biome(e) {
if (e &lt; 0.1) return WATER;
else if (e &lt; 0.2) return BEACH;
else if (e &lt; 0.3) return FOREST;
else if (e &lt; 0.5) return JUNGLE;
else if (e &lt; 0.7) return SAVANNAH;
else if (e &lt; 0.9) return DESERT;
else return SNOW;
}</pre>
        <p>Hey, looks cool! You’ll want to change the numbers and biomes for your game. Crysis will have more jungles;
            Skyrim will have more ice and snow. But no matter what you change the numbers to, this approach is a bit
            limited. The terrain types line up with the elevations, so they form bands. To make it more interesting, we
            need to choose biomes with something other than elevation. Let’s create a <em>second</em> noise map for
            “moisture”:</p>
        <figure class="img-2"><img src="images/render-both-elevation.png?2021-10-15-20-01-50" width="300"
                height="200"><img src="images/render-both-moisture.png?2021-10-15-20-01-50" width="300" height="200">
            <figcaption>Elevation noise on left; moisture noise on right</figcaption>
        </figure>
        <p>Now let’s use <em>both</em> elevation and moisture. In the diagram on the left below, the y-axis is the
            elevation (first diagram above) and the x-axis is the moisture (second diagram above). It produces a
            reasonable looking map:</p>
        <figure>
            <div style="display:grid;grid-template-columns:1fr 1em 2fr;align-items:end"><img
                    src="images/biome-lookup-discrete.png?2021-10-15-20-01-54" style="border:1px dotted #999"
                    width="200" height="200"><span></span><img
                    src="images/render-discretebiomes-3d.png?2021-10-15-20-01-53" width="300" height="200"></div>
            <figcaption>Terrain based on two noise values</figcaption>
        </figure>
        <p>Low elevations are oceans and beaches. High elevations are rocky or snowy. In between we get a wide range of
            biomes. The code looks like this:</p>
        <pre>function biome(e, m) {      
if (e &lt; 0.1) return OCEAN;
if (e &lt; 0.12) return BEACH;

if (e &gt; 0.8) {
if (m &lt; 0.1) return SCORCHED;
if (m &lt; 0.2) return BARE;
if (m &lt; 0.5) return TUNDRA;
return SNOW;
}

if (e &gt; 0.6) {
if (m &lt; 0.33) return TEMPERATE_DESERT;
if (m &lt; 0.66) return SHRUBLAND;
return TAIGA;
}

if (e &gt; 0.3) {
if (m &lt; 0.16) return TEMPERATE_DESERT;
if (m &lt; 0.50) return GRASSLAND;
if (m &lt; 0.83) return TEMPERATE_DECIDUOUS_FOREST;
return TEMPERATE_RAIN_FOREST;
}

if (m &lt; 0.16) return SUBTROPICAL_DESERT;
if (m &lt; 0.33) return GRASSLAND;
if (m &lt; 0.66) return TROPICAL_SEASONAL_FOREST;
return TROPICAL_RAIN_FOREST;
}</pre>
        <p>These are example threshold numbers. In every project I’ve worked on I’ve had to change them, not only for
            predominant biomes (Dagobah will have more swamp, Hoth will have more tundra, Tatooine will have more
            desert) but also because it depends on the noise library being used and how the octaves are mixed together.
            Plan to tweak these numbers!</p>
        <p>Alternatively if you don’t need biomes, smooth gradients (see <a
                href="http://www.shadedrelief.com/hypso/hypso.html">cartographer Tom Patterson’s article</a><sup
                class="print-endnote">[2]</sup>) can produce colors:</p>
        <figure style="display:grid;grid-template-columns:1fr 1em 2fr;align-items:end"><img
                src="images/biome-lookup-smooth.png?2021-10-15-20-01-57" style="border:1px dotted #999" width="200"
                height="200"><span></span><img src="images/render-smoothbiomes-3d.png?2021-10-15-20-01-55" width="300"
                height="200"></figure>
        <p>With either biomes or gradients, one noise value doesn’t produce enough diversity, but two is pretty good.
        </p>
    </section>
    <section>
        <h2 id="climate"><span><a href="#climate">Climate</a></span><a class="anchor" href="#climate">#</a></h2>
        <p>In the previous section I used <em>elevation</em> as a proxy for <em>temperature</em>. Higher elevations have
            lower temperatures. However, latitude also affects temperatures. Let’s use both elevation and latitude to
            control temperature:</p>
        <figure class="img-1"><img src="images/render-latitude-2d.png?2021-10-15-20-01-56" width="600"
                height="300"><br>equator: hot <input id="latitude-equator" style="width:70%" type="range" min="-2"
                max="2" step="0.01" value="-1"> cold <br>poles: hot <input id="latitude-poles" style="width:70%"
                type="range" min="-2" max="2" step="0.01" value="1"> cold</figure>
        <p>Near the poles (high latitudes) the climate is colder, and on the tops of mountains (high elevations) the
            climate is also colder. I haven’t done much with this yet. For this demo I used
            <code>e = 10*e*e + poles + (equator-poles) * sin(PI * (y / height))</code> but <em>I don’t think this is the
                best approach</em> and I think you’ll need to experiment with formulas and tweak the parameters to make
            this work the way you want.</p>
        <p>There’s also a <em>seasonal</em> variation of climate. In summer and winter the northern and southern
            hemispheres get warmer and colder, but the equator doesn’t change as much. There’s lots more that can be
            done here, such as modeling prevailing wind and ocean currents and the biome’s effect on climate and the
            ocean’s moderating effect on temperatures.</p>
    </section>
    <section>
        <h2 id="islands"><span><a href="#islands">Islands</a></span><a class="anchor" href="#islands">#</a></h2>
        <p>For some projects I want the boundaries of the map to be water. One way to do this is to generate a map as
            above and then <em>reshape</em> it.</p>
        <figure class="img-2"><img src="images/render-island-before.png?2021-10-15-20-01-52" width="300"
                height="200"><img src="images/render-island-after.png?2021-10-15-20-01-53" width="300" height="200">
            <figcaption>Before and after reshaping</figcaption>
        </figure>
        <p>How does this work? For every elevation in the range 0.0 to 1.0, we constrain it to fit a smaller range. The
            simplest approach is to <em>clamp</em> to values to the desired range. However, clamping loses detail, so I
            usually use another formula called <em>linear conversion</em>. This is the same formula we used at the
            beginning of the page to convert noise from –1.0 to +1.0 to fit into 0.0 to 1.0, but now we vary it across
            the map.</p>
        <figure id="diagram-linear-conversion"><svg viewBox="0 -5 400 115">
                <defs>
                    <marker id="arrowhead" viewBox="0 0 10 10" refX="7" refY="5" markerUnits="strokeWidth"
                        markerWidth="4" markerHeight="3" orient="auto">
                        <path d="M 0 0 L 10 5 L 0 10 z"></path>
                    </marker>
                </defs>
                <rect fill="hsl(40, 20%, 90%)" width="400" height="50"></rect>
                <rect fill="hsl(240, 30%, 90%)" y="50" width="400" height="50"></rect>
                <g fill="none" stroke="black" marker-end="url(#arrowhead)">
                    <g transform="translate(25, 0)">
                        <path d="M 0 5 C 50 5 50 2.5 100 2.5"></path>
                        <path d="M 0 15 C 50 15 50 7.5 100 7.5"></path>
                        <path d="M 0 25 C 50 25 50 12.5 100 12.5"></path>
                        <path d="M 0 35 C 50 35 50 17.5 100 17.5"></path>
                        <path d="M 0 45 C 50 45 50 22.5 100 22.5"></path>
                        <path d="M 0 55 C 50 55 50 27.5 100 27.5"></path>
                        <path d="M 0 65 C 50 65 50 32.5 100 32.5"></path>
                        <path d="M 0 75 C 50 75 50 37.5 100 37.5"></path>
                        <path d="M 0 85 C 50 85 50 42.5 100 42.5"></path>
                        <path d="M 0 95 C 50 95 50 47.5 100 47.5"></path><text stroke="none" fill="black" font-size="10"
                            x="50" y="110" text-anchor="middle">Force land</text>
                    </g>
                    <g transform="translate(150, 0)">
                        <path d="M 0 5 C 50 5 50 27.5 100 27.5"></path>
                        <path d="M 0 15 C 50 15 50 32.5 100 32.5"></path>
                        <path d="M 0 25 C 50 25 50 37.5 100 37.5"></path>
                        <path d="M 0 35 C 50 35 50 42.5 100 42.5"></path>
                        <path d="M 0 45 C 50 45 50 47.5 100 47.5"></path>
                        <path d="M 0 55 C 50 55 50 52.5 100 52.5"></path>
                        <path d="M 0 65 C 50 65 50 57.5 100 57.5"></path>
                        <path d="M 0 75 C 50 75 50 62.5 100 62.5"></path>
                        <path d="M 0 85 C 50 85 50 67.5 100 67.5"></path>
                        <path d="M 0 95 C 50 95 50 72.5 100 72.5"></path><text stroke="none" fill="black" font-size="10"
                            x="50" y="110" text-anchor="middle"></text>
                    </g>
                    <g transform="translate(275, 0)">
                        <path d="M 0 5 C 50 5 50 52.5 100 52.5"></path>
                        <path d="M 0 15 C 50 15 50 57.5 100 57.5"></path>
                        <path d="M 0 25 C 50 25 50 62.5 100 62.5"></path>
                        <path d="M 0 35 C 50 35 50 67.5 100 67.5"></path>
                        <path d="M 0 45 C 50 45 50 72.5 100 72.5"></path>
                        <path d="M 0 55 C 50 55 50 77.5 100 77.5"></path>
                        <path d="M 0 65 C 50 65 50 82.5 100 82.5"></path>
                        <path d="M 0 75 C 50 75 50 87.5 100 87.5"></path>
                        <path d="M 0 85 C 50 85 50 92.5 100 92.5"></path>
                        <path d="M 0 95 C 50 95 50 97.5 100 97.5"></path><text stroke="none" fill="black" font-size="10"
                            x="50" y="110" text-anchor="middle">Force water</text>
                    </g>
                </g>
            </svg>
            <figcaption>Linear conversion</figcaption>
        </figure>
        <p>By forcing the middle of the map to be land and the edges of the map to be water, we transform the original
            noise map into an island map. In side view, the original noise terrain fits into a containing rectangle <svg
                id="shape-island-before" width="4em" height="1em" viewBox="-1 -1 102 27">
                <path
                    d="M 0,25 L 0,0 L 5.25,0 L 10.5,0 L 15.75,0 L 21,0 L 26.25,0 L 31.5,0 L 36.75,0 L 42,0 L 47.25,0 L 52.5,0 L 57.75000000000001,0 L 63,0 L 68.25,0 L 73.5,0 L 78.75,0 L 84,0 L 89.25,0 L 94.5,0 L 99.75,0 L 100,25"
                    fill="none" stroke="#777"></path>
                <path
                    d="M 0,25 L 0,16 L 5.25,13 L 10.5,15 L 15.75,15 L 21,12 L 26.25,10 L 31.5,12 L 36.75,8 L 42,11 L 47.25,13 L 52.5,12 L 57.75000000000001,16 L 63,14 L 68.25,11 L 73.5,12 L 78.75,14 L 84,14 L 89.25,16 L 94.5,16 L 99.75,12 L 100,25"
                    fill="#ddd" stroke="black"></path>
                <path
                    d="M 0,25 L 0,25 L 5.25,25 L 10.5,25 L 15.75,25 L 21,25 L 26.25,25 L 31.5,25 L 36.75,25 L 42,25 L 47.25,25 L 52.5,25 L 57.75000000000001,25 L 63,25 L 68.25,25 L 73.5,25 L 78.75,25 L 84,25 L 89.25,25 L 94.5,25 L 99.75,25 L 100,25"
                    fill="white" stroke="#777"></path>
            </svg>. The reshaped terrain fits into <svg id="shape-island-after" width="4em" height="1em"
                viewBox="-1 -1 102 27">
                <path
                    d="M 0,25 L 0,12 L 5.25,11 L 10.5,10 L 15.75,8 L 21,7 L 26.25,6 L 31.5,4 L 36.75,3 L 42,2 L 47.25,1 L 52.5,0 L 57.75000000000001,1 L 63,2 L 68.25,3 L 73.5,4 L 78.75,6 L 84,7 L 89.25,8 L 94.5,10 L 99.75,11 L 100,25"
                    fill="none" stroke="#777"></path>
                <path
                    d="M 0,25 L 0,20 L 5.25,17 L 10.5,17 L 15.75,16 L 21,13 L 26.25,11 L 31.5,11 L 36.75,7 L 42,8 L 47.25,7 L 52.5,6 L 57.75000000000001,9 L 63,9 L 68.25,9 L 73.5,11 L 78.75,13 L 84,14 L 89.25,17 L 94.5,18 L 99.75,17 L 100,25"
                    fill="#ddd" stroke="black"></path>
                <path
                    d="M 0,25 L 0,25 L 5.25,23 L 10.5,22 L 15.75,21 L 21,20 L 26.25,18 L 31.5,17 L 36.75,16 L 42,15 L 47.25,13 L 52.5,12 L 57.75000000000001,13 L 63,15 L 68.25,16 L 73.5,17 L 78.75,18 L 84,20 L 89.25,21 L 94.5,22 L 99.75,23 L 100,25"
                    fill="white" stroke="#777"></path>
            </svg>.</p>
        <p>The simplest shape is <svg width="4em" height="1em" viewBox="-1 -1 102 27">
                <path d="M 0,13 L 50,0 L 100,13 M 0,25 L 50,13 L 100,25" fill="none" stroke="#999"></path>
            </svg>. This shape guarantees the middle is on land and the edges are in water. The nice thing about this
            shape is that’s easy to implement:</p>
        <ol>
            <li>Set <code>d</code> to the distance from the center of the map from 0 to 1. Set
                <code>nx = x/width - 0.5</code> and <code>ny = y/height - 0.5</code>. Then choose one of these distance
                functions: <dl>
                    <dt>Diagonal</dt>
                    <dd><code>d = 2 * max(abs(nx), abs(ny))</code></dd>
                    <dt>Euclidean</dt>
                    <dd><code>d = sqrt(nx*nx + ny*ny) / sqrt(0.5)</code></dd>
                    <dt>Manhattan</dt>
                    <dd><code>d = abs(nx) + abs(ny)</code></dd>
                </dl>
            </li>
            <li>Modify the elevation with <code>e = (1 + e - d) / 2</code>.</li>
        </ol>
        <p>The main problem with the simple shape is that the areas away from the edge and also away from the middle of
            the map get compressed more than necessary. After you implement the simple shape, try modifying
            <code>d</code> by raising it to a power, such as <code>d = pow(d, 0.5)</code> or <code>d = pow(d, 2)</code>.
            If that’s not enough, try defining a custom shape.</p>
        <p>For a custom shape, define two shape functions. Choose a <em>lower</em> shape to push the map <em>up</em> and
            an <em>upper</em> shape to push the map <em>down</em>. These shapes are functions that take input distance
            <code>d</code>:0–1 to output elevation:0-1. Once you have designed these shapes, reshape the noise into an
            island using <code>e = lower(d) + e * (upper(d) - lower(d))</code>. You’ll have to experiment to find
            functions that match your project’s needs.</p>
        <p>In <svg width="4em" height="1em" viewBox="-1 -1 102 27">
                <path d="M 0,15 q 50,-30,100,0 M 0,25 l 100,0" fill="none" stroke="#999"></path>
            </svg> the lower shape doesn’t push at all, so the middle of the map is not guaranteed to be on land. This
            allows more of the underlying Simplex/Perlin noise to show through. The upper shape pushes down anything
            away from the middle of the map. In <svg width="4em" height="1em" viewBox="-1 -1 102 27">
                <path d="M 0,15 c 0,-20,100,-20,100,0 M 0,25 q 50,-20,100,0" fill="none" stroke="#999"></path>
            </svg> the upper shape is less aggressive, pushing down only near the edges, and the lower shape mildly
            pushes upwards near the middle. There are many other shapes to try!</p>
        <p>Why stick to standard mathematical functions at all? As I explored in my <a
                href="https://www.redblobgames.com/articles/probability/damage-rolls.html#nonparametric">article on RPG
                damage</a><sup class="print-endnote">[3]</sup>, everyone (including me) uses mathematical functions like
            polynomials, exponentials, etc., but on a computer we’re not limited to those. We can draw <em>any</em>
            shape and use it here. Put the lower and upper shape in lookup tables and use them in your
            <code>lower(d)</code>, <code>upper(d)</code> functions.</p>
        <p>Also take a look at the island shaping functions from <a
                href="https://www.reddit.com/r/proceduralgeneration/comments/kaen7h/new_video_on_procedural_island_noise_generation/gfjmgen/">/u/KdotJPG</a><sup
                class="print-endnote">[4]</sup> and <a
                href="https://code2d.wordpress.com/2020/07/21/island-gradient/">/u/VenoMaos</a><sup
                class="print-endnote">[5]</sup>.</p>
    </section>
    <section>
        <h2 id="ridged"><span><a href="#ridged">Ridged noise</a></span><a class="anchor" href="#ridged">#</a></h2>
        <p>Instead of raising the elevation to a power, we can use absolute value to create sharp ridges:</p>
        <div style="display:grid;gap:20px;grid-template-columns:1fr 4fr;align-items:center"><svg
                viewBox="-0.11 -0.01 1.12 1.12">
                <path fill="none" stroke="#ccc" stroke-width="0.007" d="M 0,0 l 0,1 l 1,0 M 0,1 l 1,-1"></path>
                <g fill="#999" font-size="0.1" text-anchor="middle" transform="translate(0,1)"><text x="0.03"
                        y="0.1">0</text><text x="0.97" y="0.1">1</text><text x="0.5" y="0.1">Before</text>
                    <g transform="rotate(-90) translate(0,-0.02)"><text x="0.03" y="0">0</text><text x="0.97"
                            y="0">1</text><text x="0.5" y="0">After</text></g>
                </g>
                <path fill="none" stroke="#a44" stroke-width="0.02" stroke-linecap="round"
                    transform="translate(0,1), scale(1,-1)" d="M 0,0 l 0.5,1 l 0.5,-1"></path>
            </svg>
            <pre style="width:unset">function ridgenoise(nx, ny) {
return <b>2 * (0.5 - abs(0.5 - noise(nx, ny)))</b>;
}</pre>
        </div>
        <p>To add octaves, we can vary the amplitudes of the higher frequencies so that only the mountains get the added
            noise:</p>
        <pre>e0 =    1 * ridgenoise(1 * nx, 1 * ny);
e1 =  0.5 * ridgenoise(2 * nx, 2 * ny)<b> * e0</b>;
e2 = 0.25 * ridgenoise(4 * nx, 4 * ny)<b> * (e0+e1)</b>;
e = (e0 + e1 + e2) / (1 + 0.5 + 0.25);
elevation[y][x] = Math.pow(e, exponent);</pre>
        <figure class="img-1"><img src="images/render-ridged-3d.png?2018-12-28-08-36-28" width="600"
                height="400"><br>n=<input id="ridged-numlevels" type="range" min="1" max="8" value="2"><span
                class="ridged-numlevels">2</span></figure>
        <p>I don’t have much experience with this technique and will have to play with it more to learn how to use it
            well. It might also be interesting to mix ridged low frequency noise with non-ridged high frequency noise.
        </p>
    </section>
    <section>
        <h2 id="terraces"><span><a href="#terraces">Terraces</a></span><a class="anchor" href="#terraces">#</a></h2>
        <p>If we round the elevation to the nearest of <span class="terraces-numlevels">12</span> levels we get
            terraces:</p>
        <figure class="img-1"><img src="images/render-terraces-3d.png?2021-10-15-20-01-56" width="600"
                height="300"><br>n=<input id="terraces-numlevels" type="range" min="4" max="32" value="12"><span
                class="terraces-numlevels">12</span></figure>
        <div style="display:grid;gap:20px;grid-template-columns:1fr 2fr;align-items:center"><svg
                viewBox="-0.11 -0.01 1.12 1.12">
                <path fill="none" stroke="#ccc" stroke-width="0.007" d="M 0,0 l 0,1 l 1,0 M 0,1 l 1,-1"></path>
                <g fill="#999" font-size="0.1" text-anchor="middle" transform="translate(0,1)"><text x="0.03"
                        y="0.1">0</text><text x="0.97" y="0.1">1</text><text x="0.5" y="0.1">Before</text>
                    <g transform="rotate(-90) translate(0,-0.02)"><text x="0.03" y="0">0</text><text x="0.97"
                            y="0">1</text><text x="0.5" y="0">After</text></g>
                </g>
                <path id="render-terraces-line" fill="none" stroke="#a44" stroke-width="0.02" stroke-linecap="round"
                    transform="translate(0,1), scale(1,-1)"
                    d="M 0 0 L 0.0000 0.0000 L 0.0100 0.0000 L 0.0200 0.0000 L 0.0300 0.0000 L 0.0400 0.0000 L 0.0500 0.0833 L 0.0600 0.0833 L 0.0700 0.0833 L 0.0800 0.0833 L 0.0900 0.0833 L 0.1000 0.0833 L 0.1100 0.0833 L 0.1200 0.0833 L 0.1300 0.1667 L 0.1400 0.1667 L 0.1500 0.1667 L 0.1600 0.1667 L 0.1700 0.1667 L 0.1800 0.1667 L 0.1900 0.1667 L 0.2000 0.1667 L 0.2100 0.2500 L 0.2200 0.2500 L 0.2300 0.2500 L 0.2400 0.2500 L 0.2500 0.2500 L 0.2600 0.2500 L 0.2700 0.2500 L 0.2800 0.2500 L 0.2900 0.2500 L 0.3000 0.3333 L 0.3100 0.3333 L 0.3200 0.3333 L 0.3300 0.3333 L 0.3400 0.3333 L 0.3500 0.3333 L 0.3600 0.3333 L 0.3700 0.3333 L 0.3800 0.4167 L 0.3900 0.4167 L 0.4000 0.4167 L 0.4100 0.4167 L 0.4200 0.4167 L 0.4300 0.4167 L 0.4400 0.4167 L 0.4500 0.4167 L 0.4600 0.5000 L 0.4700 0.5000 L 0.4800 0.5000 L 0.4900 0.5000 L 0.5000 0.5000 L 0.5100 0.5000 L 0.5200 0.5000 L 0.5300 0.5000 L 0.5400 0.5000 L 0.5500 0.5833 L 0.5600 0.5833 L 0.5700 0.5833 L 0.5800 0.5833 L 0.5900 0.5833 L 0.6000 0.5833 L 0.6100 0.5833 L 0.6200 0.5833 L 0.6300 0.6667 L 0.6400 0.6667 L 0.6500 0.6667 L 0.6600 0.6667 L 0.6700 0.6667 L 0.6800 0.6667 L 0.6900 0.6667 L 0.7000 0.6667 L 0.7100 0.7500 L 0.7200 0.7500 L 0.7300 0.7500 L 0.7400 0.7500 L 0.7500 0.7500 L 0.7600 0.7500 L 0.7700 0.7500 L 0.7800 0.7500 L 0.7900 0.7500 L 0.8000 0.8333 L 0.8100 0.8333 L 0.8200 0.8333 L 0.8300 0.8333 L 0.8400 0.8333 L 0.8500 0.8333 L 0.8600 0.8333 L 0.8700 0.8333 L 0.8800 0.9167 L 0.8900 0.9167 L 0.9000 0.9167 L 0.9100 0.9167 L 0.9200 0.9167 L 0.9300 0.9167 L 0.9400 0.9167 L 0.9500 0.9167 L 0.9600 1.0000 L 0.9700 1.0000 L 0.9800 1.0000 L 0.9900 1.0000">
                </path>
            </svg>
            <p>This is an application of elevation redistribution functions of the form <code>e = f(e)</code>. Earlier
                we set <code>e = Math.pow(e, exponent)</code> to make mountain peaks steeper; here we use
                <code>e = Math.round(e * <span class="terraces-numlevels">12</span>) / <span class="terraces-numlevels">12</span></code>
                to make terraces. By using a function other than a step function the terraces can be rounder or only
                occur at some elevations.</p>
        </div>
    </section>
    <section>
        <h2 id="trees"><span><a href="#trees">Tree placement</a></span><a class="anchor" href="#trees">#</a></h2>
        <p>We usually use fractal noise for elevation and moisture, but it can also be used for placing irregularly
            spaced objects like trees and rocks. For elevation we have higher amplitudes with lower frequencies (“red
            noise”). For object placement we want to use higher amplitudes with higher frequencies (“blue noise”). On
            the left is a blue noise pattern; on the right are the locations where the noise is greater than the nearby
            values:</p>
        <figure class="img-2"><img src="images/render-trees-2d-in.png?2021-10-15-20-01-52" width="300" height="300"><img
                src="images/render-trees-2d-out.png?2021-10-15-20-01-52" width="300" height="300"><br>R=<input
                id="trees-radius" type="range" min="1" max="6" value="3"><span class="trees-radius">3</span></figure>
        <pre>for (int y = 0; y &lt; height; y++) {
for (int x = 0; x &lt; width; x++) {
double nx = x/width - 0.5, ny = y/height - 0.5;
// blue noise is <i>high</i> frequency; try varying this
bluenoise[y][x] = noise(50 * nx, 50 * ny); 
}
}

for (int yc = 0; yc &lt; height; yc++) {
for (int xc = 0; xc &lt; width; xc++) {
double max = 0;
// there are more efficient algorithms than this
for (int yn = yc - R; yn &lt;= yc + R; yn++) {
for (int xn = xc - R; xn &lt;= xc + R; xn++) {
if (0 &lt;= yn &amp;&amp; yn &lt; height &amp;&amp; 0 &lt;= xn &amp;&amp; xn &lt; width) {
double e = bluenoise[yn][xn];
if (e &gt; max) { max = e; }
}
}
}
if (bluenoise[yc][xc] == max) {
// place tree at xc,yc
}
}
}</pre>
        <p>By choosing a different R for each biome we can get a variable density of trees:</p>
        <div style="display:none"><img id="render-trees-2d-terrain"
                src="images/render-trees-2d-terrain.png?2021-10-15-20-01-53" width="600" height="300"><img
                id="render-trees-2d-variable-density-trees"
                src="images/render-trees-2d-variable-density-trees.png?2021-10-15-20-01-53" width="600" height="300">
        </div>
        <figure class="img-1"><canvas id="render-trees-2d-composite" width="300" height="150"></canvas></figure>
        <p>Although it’s cool that Simplex/Perlin noise can be used to place trees, other algorithms, such as jittered
            grids, Poisson discs, Wang tiles, or graphics dithering, are often more efficient and also produce a better
            distribution of trees. For trees and other object placement, <strong>I recommend using <a
                    href="http://devmag.org.za/2009/05/03/poisson-disk-sampling/">Poisson Disc</a><sup
                    class="print-endnote">[6]</sup> instead of a noise library.</strong> For Javascript, I use the <a
                href="https://github.com/kchapelier/poisson-disk-sampling">poisson-disk-sampling</a><sup
                class="print-endnote">[7]</sup> library.</p>
    </section>
    <section>
        <h2 id="wraparound"><span><a href="#wraparound">Wraparound maps</a></span><a class="anchor"
                href="#wraparound">#</a></h2>
        <p>Sometimes we want the east edge of the map to match up with the west edge. This corresponds to a
            <em>cylinder</em> in 3d space. We can implement this with a minor change. We’ll interpret the x value on the
            flat map as an <em>angle</em> in the cylinder world. Then we convert the angle to cartesian coordinates. To
            also make the north and south edges match up, we can apply the same pattern again to turn the y value into
            an angle, and look things up in a 4d noise space. Let’s see how the maps look adjacent to copies of
            themselves:</p>
        <figure class="img-2"><img src="images/render-wraparound-ew.png?2021-10-15-20-02-04" width="300"
                height="200"><img src="images/render-wraparound-nsew.png?2021-10-15-20-02-06" width="300" height="300">
            <figcaption>East+West only and North+South+East+West wraparound</figcaption>
        </figure>
        <p>The first one wraps east-west but not north-south. The second one wraps in all four directions. Here’s some
            code:</p>
        <pre>const TAU = 2 * M_PI;

function cylindernoise(double nx, double ny) {
double angle_x = TAU * nx;
/* In "noise parameter space", we need nx and ny to travel the
same distance. The circle created from nx needs to have
circumference=1 to match the length=1 line created from ny,
which means the circle's radius is 1/2π, or 1/tau */
return noise<b>3D</b>(<b>cos(angle_x)</b> / TAU, <b>sin(angle_x)</b> / TAU, ny);
}

function torusnoise(double nx, double ny) {
double angle_x = TAU * nx,
angle_y = TAU * ny;
return noise<b>4D</b>(cos(angle_x) / TAU, sin(angle_x) / TAU,
       <b>cos(angle_y) / TAU, sin(angle_y) / TAU</b>);
}</pre>
        <p>I’ve not experimented with this much yet. Take a look at <a
                href="http://ronvalstar.nl/creating-tileable-noise-maps">Ron Valstar’s guide</a><sup
                class="print-endnote">[8]</sup> for more explanation.
            <!-- - https://www.gamedev.net/blogs/entry/2138456-seamless-noise/ has broken images -->
        </p>
    </section>
    <section>
        <h2 id="infinite"><span><a href="#infinite">To infinity and beyond</a></span><a class="anchor"
                href="#infinite">#</a></h2>
        <p>The calculation of the biome at position (x,y) is independent of calculations at any other position. This
            <strong>local calculation</strong> results in two nice properties: it can be calculated in parallel, and it
            can be used for infinite terrain. <strong class="hover-available">Put the mouse over the
                minimap</strong><strong class="hover-unavailable">Touch the minimap</strong> on the left to generate a
            map on the right. We can generate any part of the map without generating (or having to store) the whole
            thing.</p>
        <figure style="display:grid;grid-template-columns:1fr 2fr;align-items:end;grid-column-gap:10px"><span
                class="mouseover"><img src="images/scrolling.png?2021-10-15-20-01-57" style="touch-action: none;"
                    width="200" height="200"></span><img src="images/render-scrolling-3d.png?2021-10-15-20-01-58"
                width="400" height="200"></figure>
        <p>How can you do this in your own code? It’s a small change to the code we’ve already been using. Find the
            places where you have calls to <code>noise(…, …)</code> and replace them by
            <code>noise(… - camera.x, … - camera.y)</code>. In my demo, I use the mouse position to set
            <code>camera.x</code> and <code>camera.y</code> but you might use <kbd>W A S D</kbd> or other controls to
            move the camera around your infinite map.</p>
    </section>
    <section>
        <h2 id="implementation"><span><a href="#implementation">Implementation</a></span><a class="anchor"
                href="#implementation">#</a></h2>
        <p>Using noise for generating terrain is a popular technique, and you can find tutorials for many different
            languages and platforms. The map generation code is pretty similar across languages. Here’s the simplest
            loop, in three different languages:</p>
        <ul>
            <li><b>Javascript:</b>
                <pre>let gen = new SimplexNoise();
function noise(nx, ny) {
// Rescale from -1.0:+1.0 to 0.0:1.0
return gen.noise2D(nx, ny) / 2 + 0.5;
}

let value = [];   
for (let y = 0; y &lt; height; y++) {
value[y] = [];
for (let x = 0; x &lt; width; x++) {      
let nx = x/width - 0.5, ny = y/height - 0.5;
value[y][x] = noise(nx, ny);
}
}</pre>
            </li>
            <li><b>C++:</b>
                <pre>module::Perlin gen; // if using libnoise
double noise(double nx, double ny) { // if using libnoise
// Rescale from -1.0:+1.0 to 0.0:1.0
return gen.GetValue(nx, ny, 0) / 2.0 + 0.5;
}

FastNoiseLite gen; // if using fastnoiselite
double noise(double nx, double ny) { // if using fastnoiselite
// Rescale from -1.0:+1.0 to 0.0:1.0
return gen.GetNoise(nx, ny) / 2.0 + 0.5;
}

double value[height][width];
for (int y = 0; y &lt; height; y++) {
for (int x = 0; x &lt; width; x++) {
double nx = x/width - 0.5, 
ny = y/height - 0.5;
value[y][x] = noise(nx, ny);
}
}</pre>
            </li>
            <li><b>Python:</b>
                <pre>from opensimplex import OpenSimplex
gen = OpenSimplex()
def noise(nx, ny):
# Rescale from -1.0:+1.0 to 0.0:1.0
return gen.noise2d(nx, ny) / 2.0 + 0.5

value = []
for y in range(height):
value.append([0] * width)
for x in range(width):
nx = x/width - 0.5
ny = y/height - 0.5
value[y][x] = noise(nx, ny)</pre>
            </li>
        </ul>
        <p>Once you have a noise library, the code is similar. Beward: some libraries combine multiple octaves
            automatically, which is convenient but makes it hard to mix them in your own way.</p>
        <ul>
            <li><strong>Python</strong>: <a href="https://pypi.python.org/pypi/opensimplex/">opensimplex for
                    Python</a><sup class="print-endnote">[9]</sup></li>
            <li><strong>C++</strong>: <a href="https://github.com/SRombauts/SimplexNoise">SimplexNoise</a><sup
                    class="print-endnote">[10]</sup> or <a
                    href="https://github.com/Auburn/FastNoiseLite">FastNoiseLite</a><sup
                    class="print-endnote">[11]</sup> or <a href="http://libnoise.sourceforge.net/docs/">libnoise</a><sup
                    class="print-endnote">[12]</sup></li>
            <li><strong>Javascript</strong>: <a href="https://www.npmjs.com/package/simplex-noise">simplex-noise</a><sup
                    class="print-endnote">[13]</sup></li>
            <li><strong>Java, C#</strong>: <a href="https://github.com/KdotJPG/OpenSimplex2">opensimplex2</a><sup
                    class="print-endnote">[14]</sup></li>
            <li><strong>Unity</strong>: <a
                    href="https://docs.unity3d.com/Packages/com.unity.mathematics@0.0/api/Unity.Mathematics.noise.html">Unity.Mathematics.noise</a><sup
                    class="print-endnote">[15]</sup> or <a
                    href="https://docs.unity3d.com/ScriptReference/Mathf.PerlinNoise.html">Mathf.PerlinNoise</a><sup
                    class="print-endnote">[16]</sup></li><!-- common lisp https://github.com/fsmunoz/cl-rebonoise -->
        </ul>
        <p>There are lots of noise libraries for most popular languages. Alternatively, you may want to spend time
            studying how Simplex noise works, or implementing it yourself. <em>I didn’t.</em></p>
        <p>Once you have found a noise library for your favorite language, the details will vary (some will return
            numbers from 0.0 to 1.0 and others from -1.0 to +1.0) but the basic idea is the same. For a real project you
            may want to wrap the <code>noise</code> function and the <code>gen</code> object into a class but those
            details aren’t relevant here so I made them global.</p>
        <p>For this simple project it doesn’t matter that much whether you use Simplex noise, OpenSimplex noise, Perlin
            noise, value noise, midpoint displacement, diamond displacement, or an inverse Fourier transform. There are
            pros and cons of each of these but they all produce similar enough output for this type of map generator.
        </p>
        <p>The <em>drawing</em> of the map is going to be platform-specific and game-specific so I’m not providing that;
            this code is to generate the elevations and biomes, which you’ll want to draw yourself in whatever style
            your game uses. Feel free to copy, port, and use it for your own projects.</p>
    </section>
    <section>
        <h2 id="demo"><span><a href="#demo">Playground</a></span><a class="anchor" href="#demo">#</a></h2>
        <p>I’ve covered mixing octaves, raising the elevation to a power, and combining elevation and moisture to pick a
            biome. Here’s an interactive diagram that lets you play with all of these parameters, and then shows how the
            code is put together:</p>
        <figure class="img-1"><img src="images/finaldemo-3d.png?2021-10-15-20-01-58" width="600"
                height="300"><br>exp=<input id="final-exponent" type="range" min="0.5" max="15" step="0.01" value="5">
            <div class="sidebyside">Elevation octaves: <br>e1=<input id="final-e1" type="range" min="0" max="1"
                    step="0.01" value="1.0"><br>e2=<input id="final-e2" type="range" min="0" max="1" step="0.01"
                    value="0.5"><br>e3=<input id="final-e3" type="range" min="0" max="1" step="0.01"
                    value="0.25"><br>e4=<input id="final-e4" type="range" min="0" max="1" step="0.01"
                    value="0.125"><br>e5=<input id="final-e5" type="range" min="0" max="1" step="0.01"
                    value="0.0625"><br>e6=<input id="final-e6" type="range" min="0" max="1" step="0.01" value="0.03125">
            </div>
            <div class="sidebyside">Moisture octaves: <br>m1=<input id="final-m1" type="range" min="0" max="1"
                    step="0.01" value="1.0"><br>m2=<input id="final-m2" type="range" min="0" max="1" step="0.01"
                    value="0.75"><br>m3=<input id="final-m3" type="range" min="0" max="1" step="0.01"
                    value="0.33"><br>m4=<input id="final-m4" type="range" min="0" max="1" step="0.01"
                    value="0.33"><br>m5=<input id="final-m5" type="range" min="0" max="1" step="0.01"
                    value="0.33"><br>m6=<input id="final-m6" type="range" min="0" max="1" step="0.01" value="0.5"></div>
        </figure>
        <p>Here’s the code:</p>
        <pre>var rng1 = PM_PRNG.create(seed1);
var rng2 = PM_PRNG.create(seed2);
var gen1 = new SimplexNoise(rng1.nextDouble.bind(rng1));
var gen2 = new SimplexNoise(rng2.nextDouble.bind(rng2));
function noise1(nx, ny) { return gen1.noise2D(nx, ny)/2 + 0.5; }
function noise2(nx, ny) { return gen2.noise2D(nx, ny)/2 + 0.5; }

for (var y = 0; y &lt; height; y++) {
for (var x = 0; x &lt; width; x++) {      
var nx = x/width - 0.5, ny = y/height - 0.5;
var e = (<span class="final-e1">1.00</span> * noise1( 1 * nx,  1 * ny)
+ <span class="final-e2">0.50</span> * noise1( 2 * nx,  2 * ny)
+ <span class="final-e3">0.25</span> * noise1( 4 * nx,  4 * ny)
+ <span class="final-e4">0.13</span> * noise1( 8 * nx,  8 * ny)
+ <span class="final-e5">0.06</span> * noise1(16 * nx, 16 * ny)
+ <span class="final-e6">0.03</span> * noise1(32 * nx, 32 * ny));
e = e / (<span class="final-e1">1.00</span> + <span class="final-e2">0.50</span> + <span class="final-e3">0.25</span> + <span class="final-e4">0.13</span> + <span class="final-e5">0.06</span> + <span class="final-e6">0.03</span>);
e = Math.pow(e, <span class="final-exponent">5.00</span>);
var m = (<span class="final-m1">1.00</span> * noise2( 1 * nx,  1 * ny)
+ <span class="final-m2">0.75</span> * noise2( 2 * nx,  2 * ny)
+ <span class="final-m3">0.33</span> * noise2( 4 * nx,  4 * ny)
+ <span class="final-m4">0.33</span> * noise2( 8 * nx,  8 * ny)
+ <span class="final-m5">0.33</span> * noise2(16 * nx, 16 * ny)
+ <span class="final-m6">0.50</span> * noise2(32 * nx, 32 * ny));
m = m / (<span class="final-m1">1.00</span> + <span class="final-m2">0.75</span> + <span class="final-m3">0.33</span> + <span class="final-m4">0.33</span> + <span class="final-m5">0.33</span> + <span class="final-m6">0.50</span>);
/* draw biome(e, m) at x,y */
}
}</pre>
        <p>A tricky bit: you need to use different seeds for the elevation and moisture noise. Otherwise they’ll end up
            being the same, and your maps won’t look nearly as interesting. In Javascript I use the <a
                href="https://www.npmjs.com/package/prng-parkmiller-js">prng-parkmiller library</a><sup
                class="print-endnote">[17]</sup>; in C++ you can use two separate <a
                href="http://www.cplusplus.com/reference/random/linear_congruential_engine/linear_congruential_engine/">linear_congruential_engine
                objects</a><sup class="print-endnote">[18]</sup>; in Python you can instantiate two separate instances
            of the <a href="https://docs.python.org/3/library/random.html">random.Random class</a><sup
                class="print-endnote">[19]</sup>.</p>
        <p>Another tricky bit: once you combine multiple octaves of noise, the range of output may not be what you
            expected, and you may have to add/multiply the output value into the desired range (such as 0.0 to 1.0).
            Scott Turner has <a href="https://heredragonsabound.blogspot.com/2016/10/is-it-noisy-in-here.html">written a
                bit more about common issues with noise</a><sup class="print-endnote">[20]</sup>; Rudi Chen <a
                href="https://digitalfreepen.com/2017/06/20/range-perlin-noise.html">has analyzed the range of output
                for Perlin Noise</a><sup class="print-endnote">[21]</sup>; and KDotJPG <a
                href="https://noiseposti.ng/posts/2021-03-22-Normalizing-Gradient-Noise.html">has studied the problem
                for Simplex, OpenSimplex, and Perlin Noise</a><sup class="print-endnote">[22]</sup>.</p>
    </section>
    <section>
        <h2 id="thoughts"><span><a href="#thoughts">Thoughts</a></span><a class="anchor" href="#thoughts">#</a></h2>
        <p>What I like about this approach to map generation is that <b>it’s simple</b>. It’s fast. It’s very little
            code to produce decent results.</p>
        <p>What I don’t like about this approach is that it’s limited. Local calculation means every location is
            independent of every other location. Different areas of the map <em>don’t relate to each other</em>. Every
            place on the map “feels” the same. There are no global constraints like “there should be between 3 and 5
            lakes” or global features like a river flowing from the top of the highest peak down to the ocean. Another
            thing I don’t like is that it takes a lot of tweaking of parameters to get something you like.</p>
        <p>Why do I recommend it then? I think it’s a good starting point, especially for indie games or game jams. Two
            of my friends wrote the initial version of <a
                href="https://en.wikipedia.org/wiki/Realm_of_the_Mad_God">Realm of the Mad God</a><sup
                class="print-endnote">[23]</sup> in 30 days, for a <a
                href="http://www.tigsource.com/2010/02/07/assemblee-competition-results/">game competition</a><sup
                class="print-endnote">[24]</sup>. They asked me to help them make the maps. I used this technique (plus
            some extra features that turned out not to be that useful) to make a map for them. Months later, after
            getting feedback from players and looking at the game design a lot more, we designed the more advanced map
            generator using Voronoi polygons, described <a
                href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">here</a><sup
                class="print-endnote">[25]</sup>. That map generator doesn’t use the techniques from this page, but uses
            noise very differently to produce maps.</p>
        <p>Noise-based elevation is fun and easy to get started with but you can quickly run into limits. Scott Turner
            <a href="https://heredragonsabound.blogspot.com/2019/02/perlin-noise-procedural-content.html">has an
                insightful essay with reasons to use alternatives</a><sup class="print-endnote">[26]</sup>. Artifexian’s
            video on <a href="https://www.youtube.com/watch?v=ztemzsxso0U">coastlines</a><sup
                class="print-endnote">[27]</sup> gives a sense of just how limited noise-based terrain is.</p>
    </section>
    <section>
        <h2 id="more"><span><a href="#more">More</a></span><a class="anchor" href="#more">#</a></h2>
        <p>There are <em>lots</em> of cool things you can do with noise functions. If you search the web you’ll see
            variants such as turbulence, billow, ridged multifractal, amplitude damping, terraced, voronoi noise,
            analytical derivatives, domain warping, and others. Take a look at <a
                href="http://iquilezles.org/www/articles/warp/warp.htm">this page</a><sup
                class="print-endnote">[28]</sup> for inspiration. I’m not covering them here; instead I’m focused on
            simplicity for this article.</p>
        <!--
https://gamedev.stackexchange.com/questions/183331/how-can-i-create-a-six-sided-tillable-perlin-noise-image

-->
        <p>My previous map generation projects that influenced this one:</p>
        <ul>
            <li>I used generic Perlin noise for <a
                    href="http://simblob.blogspot.com/2010/01/simple-map-generation.html">my first Realm of the Mad God
                    map generator</a><sup class="print-endnote">[29]</sup>. We used that for the first six months of
                alpha testing, and then replaced it with a custom-designed <a
                    href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">Voronoi
                    polygon map generator</a><sup class="print-endnote">[30]</sup> based on the gameplay needs we
                identified during the alpha testing. The biomes in this article and their colors come from those
                projects.</li>
            <li>While studying signal processing for audio, I wrote <a href="/articles/noise/">a tutorial on noise</a>
                that covers concepts like frequency, amplitude, octaves, and “colors” of noise. The same concepts that
                work for audio also apply to noise-based map generation. I made some unpolished <a
                    href="/articles/noise/2d/">terrain generation demos</a> at the time but never finished them.</li>
            <li>Sometimes I experiment to find limits. I wanted to see how little code I could get away with while still
                producing reasonable maps. In <a href="/x/1446-svg-filters/">this mini-project</a> I got down to
                <b>zero</b> lines of code— it’s all image filters (turbulence, threshold, color gradients). I was both
                pleased and disturbed by this. How much of map generation can be done with image filters? Quite a lot.
                Everything in the “smooth gradient color scheme” I described earlier came from this experiment. The
                noise layer is a turbulence image filter; the octaves are images layered on top of each other; the
                exponent is called the “curves adjustment” tool in Photoshop.</li>
        </ul>
        <p>It bothers me somewhat that most of the code we game developers write for noise-based terrain generation
            (including midpoint displacement) turns out to be the same as audio and image filters. On the other hand, it
            produces decent results with very little code, so that’s why I wrote the article you’re reading. It’s a
            <em>quick &amp; easy starting point</em>. I usually don’t use these types of maps for long; I’ll replace
            them with a custom map generator once more of the game is built and I have a better sense of what types of
            maps best match that game’s design. That’s a common pattern for me: start with something extremely simple,
            then replace it only after I better understand the system I’m working on.</p>
        <p>There are a <em>lot</em> of cool things you can do with noise, and I’ve barely explored them here. Try out
            the <a href="https://codepen.io/MittenedWatchmaker/full/aVeoRM/">Noise Studio</a><sup
                class="print-endnote">[31]</sup> to interactively explore lots of possibilities. Also:</p>
        <ul>
            <li><a href="https://www.iquilezles.org/www/index.htm">Inigo Quilezles</a><sup
                    class="print-endnote">[32]</sup>, a <em>must read</em></li>
            <li><a href="https://www.gdcvault.com/play/1024514/Building-Worlds-Using">Building Worlds Using
                    Maths</a><sup class="print-endnote">[33]</sup> - Sean Murray of No Man’s Sky; skip to 20 minutes in.
            </li>
            <li><a href="https://www.gdcvault.com/play/1024265/Continuous_World_Generation_in__No_Man_s_Sky_">Continuous
                    World Generation in No Man’s Sky - Innes McKendrick</a><sup class="print-endnote">[34]</sup></li>
        </ul>
        <!--

https://www.decarpentier.nl/scape-procedural-extensions

"Swiss turbulence", "Jordan turbulence"

-->
    </section>
</main>
<div class="below-divider">
    <p>Email me <a class="email" rel="me" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>, or tweet <a
            rel="me" href="https://twitter.com/redblobgames">@redblobgames</a>, or comment:</p>
    <div class="print-endnote">
        <h3>Endnotes</h3>
        <ol>
            <li>[1]:&nbsp;http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/</li>
            <li>[2]:&nbsp;http://www.shadedrelief.com/hypso/hypso.html</li>
            <li>[3]:&nbsp;https://www.redblobgames.com/articles/probability/damage-rolls.html#nonparametric</li>
            <li>[4]:&nbsp;https://www.reddit.com/r/proceduralgeneration/comments/kaen7h/new_video_on_procedural_island_noise_generation/gfjmgen/
            </li>
            <li>[5]:&nbsp;https://code2d.wordpress.com/2020/07/21/island-gradient/</li>
            <li>[6]:&nbsp;http://devmag.org.za/2009/05/03/poisson-disk-sampling/</li>
            <li>[7]:&nbsp;https://github.com/kchapelier/poisson-disk-sampling</li>
            <li>[8]:&nbsp;http://ronvalstar.nl/creating-tileable-noise-maps</li>
            <li>[9]:&nbsp;https://pypi.python.org/pypi/opensimplex/</li>
            <li>[10]:&nbsp;https://github.com/SRombauts/SimplexNoise</li>
            <li>[11]:&nbsp;https://github.com/Auburn/FastNoiseLite</li>
            <li>[12]:&nbsp;http://libnoise.sourceforge.net/docs/</li>
            <li>[13]:&nbsp;https://www.npmjs.com/package/simplex-noise</li>
            <li>[14]:&nbsp;https://github.com/KdotJPG/OpenSimplex2</li>
            <li>[15]:&nbsp;https://docs.unity3d.com/Packages/com.unity.mathematics@0.0/api/Unity.Mathematics.noise.html
            </li>
            <li>[16]:&nbsp;https://docs.unity3d.com/ScriptReference/Mathf.PerlinNoise.html</li>
            <li>[17]:&nbsp;https://www.npmjs.com/package/prng-parkmiller-js</li>
            <li>[18]:&nbsp;http://www.cplusplus.com/reference/random/linear_congruential_engine/linear_congruential_engine/
            </li>
            <li>[19]:&nbsp;https://docs.python.org/3/library/random.html</li>
            <li>[20]:&nbsp;https://heredragonsabound.blogspot.com/2016/10/is-it-noisy-in-here.html</li>
            <li>[21]:&nbsp;https://digitalfreepen.com/2017/06/20/range-perlin-noise.html</li>
            <li>[22]:&nbsp;https://noiseposti.ng/posts/2021-03-22-Normalizing-Gradient-Noise.html</li>
            <li>[23]:&nbsp;https://en.wikipedia.org/wiki/Realm_of_the_Mad_God</li>
            <li>[24]:&nbsp;http://www.tigsource.com/2010/02/07/assemblee-competition-results/</li>
            <li>[25]:&nbsp;http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/</li>
            <li>[26]:&nbsp;https://heredragonsabound.blogspot.com/2019/02/perlin-noise-procedural-content.html</li>
            <li>[27]:&nbsp;https://www.youtube.com/watch?v=ztemzsxso0U</li>
            <li>[28]:&nbsp;http://iquilezles.org/www/articles/warp/warp.htm</li>
            <li>[29]:&nbsp;http://simblob.blogspot.com/2010/01/simple-map-generation.html</li>
            <li>[30]:&nbsp;http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/</li>
            <li>[31]:&nbsp;https://codepen.io/MittenedWatchmaker/full/aVeoRM/</li>
            <li>[32]:&nbsp;https://www.iquilezles.org/www/index.htm</li>
            <li>[33]:&nbsp;https://www.gdcvault.com/play/1024514/Building-Worlds-Using</li>
            <li>[34]:&nbsp;https://www.gdcvault.com/play/1024265/Continuous_World_Generation_in__No_Man_s_Sky_</li>
        </ol>
    </div>
    <div class="comments" role="complementary">
        <div id="disqus_thread"><button style="padding:1em;width:100%" onclick="$disqus()">Load comments</button></div>
        <script>
            function disqus_config() { this.page.url = "http://www.redblobgames.com/maps/terrain-from-noise/" }
            function $disqus() { $disqus = () => { }; $l("//redblobgames.disqus.com/embed.js") }
            if (document.location.hash.match(/#comment/)) setTimeout($disqus, 0)
            else if ('IntersectionObserver' in window) { new IntersectionObserver(e => { if (e[0].isIntersecting) $disqus() }).observe(document.getElementById('disqus_thread')) }</script>
        <noscript><a href="//redblobgames.disqus.com/?url=https://www.redblobgames.com/maps/terrain-from-noise/">View
                the discussion thread.</a></noscript>
    </div>
</div>
<footer>
    <div>
        <address>
            Copyright © 2022
            <a rel="author home copyright" href="//www.redblobgames.com/">Red Blob Games</a><br><a
                href="https://simblob.blogspot.com/feeds/posts/default"><svg viewBox="0 0 30 30" height="1em"
                    style="vertical-align:text-bottom">
                    <rect width="30" height="30" rx="5" fill="orange"></rect>
                    <circle cx="7" cy="23" r="4" fill="white"></circle>
                    <path d="M 5,5 A 20,20,0,0,1,25,25 M 5,13 A 12,12,0,0,1,17,25" fill="none" stroke="white"
                        stroke-width="4" stroke-linecap="square"></path>
                </svg>RSS Feed</a>
        </address>
        <div>
            &nbsp;Created 07 Jul 2015; &nbsp;
            <!-- hhmts start -->Last modified: 12 Feb 2022
            <!-- hhmts end -->
        </div>
    </div>
</footer>