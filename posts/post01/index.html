<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>EarthMakerLite</title>
        <link rel="stylesheet" type="text/css" href="https://weimil.github.io/style.css">
        <link rel="icon" href="https://weimil.github.io/images/WTech.svg" type="image/x-icon">
    </head>

    <body>
        <header>
            <h1>EarthMakerLite</h1>
            <h3>from <a href="https://weimil.github.io/index.html">WTech</a></h3>
            <nav>
                <ul>
                    <li><a href="https://weimil.github.io/index.html">Home</a></li>
                    <li><a href="https://github.com/Weimil">GitHub</a></li>
                    <li><a href="">About</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <div id="TableOfContent">
                <h2>Table de contenido</h2>
                <ul>
                    <li><a href="#AcercaDelProyecto">Acerca del proyecto</a></li>
                    <li><a href="#GeneracionProcedural">Generación Procedural</a></li>
                    <li><a href="#Ruido">Ruido</a></li>
                    <li><a href="#EstructuraDelJuego">Estructura del juego</a></li>
                    <li><a href="#Bloques">Los bloques</a></li>
                    <li><a href="#Population">Population</a></li>
                    <li><a href="#ResultadoFinal">Resultado final</a></li>
                </ul>
            </div>

            <div id="LastUpdate">
                LastUpdate: 25th Febrary 2022
                <a href="#ChangeLog">#</a>
            </div>

            <section>
                <h2 id="AcercaDelProyecto">
                    <a href="#AcercaDelProyecto">Acerca del proyecto</a>
                    <a href="#AcercaDelProyecto" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>

                <p>
                    Desde siempre me he considerado un desarrollador de backend. Me gusta ver interfaces bonitas claro, como a todo el mundo, pero lo que realmente me gusta es hacer que esa interfaz responda lo más rápidamente posible. 
                    <br><br>
                    Así que cuando me puse a pensar acerca de tema de mi juego lo único en lo que podía pensar era, ¿Como puedo hacer un juego sin preocuparme del aspecto gráfico o la jugabilidad?.
                    <br><br>
                    De inmediato pensé en Minecraft, no por el aspecto gráfico, sino por lo mucho que se acerca del juego. Así que pensé en recrear la redstone. Después de pensar un poco supe que era algo básicamente imposible para mi.
                    <br><br>
                    Así que el siguiente sistema del que mas se del juego es la generación de terreno y del conocido como "seedFinding" y "seedHunting".
                    <br><br>
                    Dicho esto empecemos con la explicación de como EarthMaker en su versión Lite funciona.
                </p>
            </section>

            <section>
                <h2 id="GeneracionProcedural">
                    <a href="#GeneracionProcedural">Generación Procedural</a>
                    <a href="#GeneracionProcedural" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>
                <p>
                    La generación procedural es la base de este proyecto y es la técnica de hacer que un ordenador cree algo para que un humano no tenga que hacerlo.
                    <br><br>
                    Para ello se usan diferentes técnicas que se basan en transformar números generados aleatoria o pseudoaleatoriamente, en propiedades de un objeto.
                    <br><br>
                    Pero un ordenador no sabe como hacer esas cosas si previamente no le estableces una serie de reglas que definirán como se generaran dichos objetos.
                    <br><br>
                    La mejor manera de verlo es con un ejemplo:
                    <br><br>
                    Esta es una definición básica de un objeto "libro" con el tipo de tapa, el género y el número de páginas como atributos. El objeto "libro" también cuenta con un constructor que inicializa todos los atributos del objeto.
                </p>

                <div class="img1">
                    <img src="images/ClassBook.png" alt="ClassBook">
                </div>

                <p>
                    Para definir el tipo de tapa y el género, usamos dos enumeraciones donde almacenamos todas las posibilidades.
                </p>

                <div class="img1">
                    <img src="images/EnumTapa.png" alt="EnumTapa">
                </div>

                <div class="img1">
                    <img src="images/EnumGenero.png" alt="EnumGenero">
                </div>

                <p>
                    A la hora de generar un nuevo libro hacemos uso de la clase Random. Aunque estamos trabajando con Unity y este ofrece su propia implementación de la clase Random, para este ejemplo se usa la del paquete System.
                </p>

                <div class="img1">
                    <img src="images/MethodGenerateBook.png" alt="MethodGenerateBook">
                </div>

                <p>
                    Tras ejecutar el método "GeneraLibros" tendríamos como resultado una array del tamaño que hemos especificado con el parametro "nuemeroLibros" de libros generados proceduralmente. 
                </p>
            </section>

            <section>
                <h2 id="Ruido">
                    <a href="#Ruido">Ruido</a>
                    <a href="#Ruido" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>
                <p>
                    Antes he mencionado el término "pseudoaleatorio", que implica que algo, en este caso un número, sea pseudoaleatorio?
                    <br><br>
                    Un número pseudoaleatorio es un número generado en un proceso que parece producir números al azar, pero no lo hace realmente. Las secuencias de números pseudoaleatorios no muestran ningún patrón o regularidad aparente desde un punto de vista estadístico, a pesar de haber sido generadas por un algoritmo completamente determinista, en el que las mismas condiciones iniciales producen siempre el mismo resultado.
                    <br><br>
                    De todos modos al igual que antes la forma más fácil de mostrar la diferencia entre una secuencia de números pseudoaleatorios y una de números aleatorios es con un ejemplo.
                    <br><br>
                    Este es un ejemplo de un mapa de ruido completamente aleatorio:
                </p>

                <div class="img1">
                    <img src="images/ExampleRandomNoise.png" alt="ExampleRandomNoise">
                </div>

                <p>
                    Y este es un ejemplo de un mapa de ruido pseudoaleatorio también conocido como ruido coherente generado usando un algoritmo llamado SimplexNoise:
                </p>

                <div class="img1">
                    <img src="images/ExampleSimplexNoise.png" alt="ExampleSimplexNoise">
                </div>

                <p>
                    Hay una clara diferencia entre los dos tipos de mapas de ruido siendo la más importante la distribución más natural de los valores.
                    <br><br>
                    Mientras que en el ruido aleatorio el color negro más oscuro puede estar junto al blanco más claro en el caso del pseudoaleatorio esa situación es imposible.
                </p>
            </section>
        
            <section>
                <h2 id="EstructuraDelJuego">
                    <a href="#EstructuraDelJuego">Estructura del juego</a>
                    <a href="#EstructuraDelJuego" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>
                
                <p>
                    Vamos a dejar apartado el ruido y los números pseudoaleatorios para dar un poco de contexto a como funciona EarthMaker antes de que esos conceptos entren en juego.
                    <br><br>
                    El primer concepto, aunque no entraré en mucho detalle, es la malla de renderizado o mesh. Esta es la encargada de que un objeto se vea y tenga una forma.
                    <br><br>
                    Tener muchas mallas en pantalla puede causar muchos problemas de rendimiento dado que Unity trata cada malla como una llamada de dibujado diferente. Así que tener cada bloque del mundo como una malla implicaría tener serios problemas de rendimiento.
                    <br><br>
                    Tener una malla muy grande también puede dar muchos problemas. Dado que cada vez que una nueva área del mundo tuviese que ser generada la malla de todo el mundo tendría que eliminarse y recrearse otra vez.
                    <br><br>
                    Así que la solución es ir agrupando los bloques, que son de 1 metro de largo, en diferentes paquetes con un tamaño razonable con el que sea más fácil trabajar. Estos paquetes los llamaremos chunks.
                    <br><br>
                    Un chunk es un conjunto de 16x256x16 bloques. Una Región es un conjunto de 32x32 chunks y el Mundo es el conjunto de todas las regiones existentes.
                    <br><br>
                    Para que este más claro estos son los scrips, sin toda la funcionalidad, del Mundo y de la Región.
                    <br><br>
                    Aquí podemos ver como la clase Mundo guarda las regiones en un diccionario en el que la clave es un Vector2 que se usa como identificador de la Región.
                </p>

                <div class="img1">
                    <img src="images/ClassWorld.png" alt="ClassWorld">
                </div>

                <p>
                    Y con la clase Región pasa algo parecido, siendo las diferencia respecto a la clase Mundo que la Región almacena Chunks y que el método Load ahora es un método asíncrono.
                </p>

                <div class="img1">
                    <img src="images/ClassRegion.png" alt="ClassRegion">
                </div>

                <p>
                    Y por último la más compleja de las clases, Chunk. Al igual que en los ejemplos anteriores la clase esta simplificada, pero de momento solo hace falta que conozcáis la estructura general. 
                </p>

                <div class="img1">
                    <img src="images/ClassChunk.png" alt="ClassChunk">
                </div>
            </section>

            <section>
                <h2 id="MapaDeAltura">
                    <a href="#MapaDeAltura">Mapa de altura</a>
                    <a href="#MapaDeAltura" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>
                <p>
                    Ahora que ya sabéis de donde aparecen estos Chunks y cual es su estructura, toca volver a los números pseudoaleatorios y el ruido coherente.
                    <br><br>
                    El ruido por si solo es simplemente un montón de números. Lo que tenemos que hacer es darles un significado. Lo primero que nos viene a la cabeza al pensar en generación de terreno es la forma del terreno, el relieve. Así que empezaremos por asignar este ruido a la altura.
                    <br><br>
                    Pero antes tengo que hacer una anotación. Antes he mencionado que en EarthMaker cada bloque tiene un metro de altura. El ruido no es mas que un montón de números en el rango de -1 a 1. Lo cual significa que el resultado seria un mundo practicamente plano.
                    <br><br>
                    Para solucionar esto tenemos que convertir estos valores a unos que puedan representar el relieve de un terreno.
                    <br><br>
                    El primer modificador del que hablare será la amplitud. La amplitud es la encargada de determinar cual sera el rango de alturas alas que el ruido podrá llegar. Como siempre un ejemplo es la mejor manera de explicarlo.
                    <br><br>
                    En este caso no estoy usando ruido pero la función sin(x) para simplificar las cosas un poco.
                </p>

                <p>
                    <br><a href="https://www.desmos.com/calculator/gbrikfkap2">Desmos</a>
                </p>

                <div class="img1">
                    <img src="images/DesmosAmplitud.png" alt="DesmosAmplitud">
                </div>

                <p>
                    El segundo de estos modificador sera la frecuencia esta determina la distancia entre los picos de cada montaña. En el caso de EarthMaker no se usa la frecuencia se usa el ancho de onda, esta esta directamente relacionada con la frecuencia: AnchoDeOnda = TamañoDeMapa / Frecuencia.
                    <br><br>
                    El porque de usar el ancho de onda y no la frecuencia es porque necesito que la frecuencia sea muy baja, de 0,1 o 0,05. Usar el ancho de onda me permite usar números mas grandes, 128 o 192 dado que la frecuencia se aplica multiplicando la coordenada y la frecuencia mientras que con el ancho de onda es una división.
                </p>

                <p>
                    <br><a href="https://www.desmos.com/calculator/ney5avfsuy">Desmos</a>
                </p>

                <div class="img1">
                    <img src="images/DesmosFrecuencia.png" alt="DesmosFrecuencia">
                </div>

                <p>
                    La el mapa de ruido nos devuelve números entre -1 y 1. Para conseguir montañas mas altas a la vez que valles entre dichas montañas podemos elevar dicho valor a un exponente. podemos verlo fácilmente en es gráfico, pero de esta manera conseguimos hacer que la amplitud no sea el único modificador que altere la altura del terreno, dandonos mas opciones.
                </p>

                <p>
                    <br><a href="https://www.desmos.com/calculator/olgshm23ir">Desmos</a>
                </p>

                <div class="img1">
                    <img src="images/DesmosRedistribution.png" alt="DesmosRedistribution">
                </div>

                <p>
                    Con este modificador lo que vamos a hacer es hacer mas interesante el mapa de altura añadiendo varios mapas de ruido con diferentes frecuencias.
                    <br><br>
                    Con esto conseguimos terrenos mucho mas detallados, el principio de este modificador es que el primero de los Octaves será el que dará la forma general al terreno y los siguientes irán dando mas detalle al terreno.
                    <br><br>
                    Seria como ir pintando cada vez con un pincel mas pequeño, el objetivo con un pincel la 5 veces mas pequeño que el primero no es cambiar drásticamente el cuadro, sino añadir sombras y trazo mas complejos que no podrías con un pincel mas grande.
                </p>

                <p>
                    <br><a href="https://www.desmos.com/calculator/sg5ytj2mo1">Desmos</a>
                </p>

                <div class="img1">
                    <img src="images/DesmosOctaves.png" alt="DesmosOctaves">
                </div>

                <p>
                    En este ultimo gráfico podemos ver como interactúan algunos los modificadores juntos.
                    <br><a href="https://www.desmos.com/calculator/dgkwyi1v89">Desmos</a>
                </p>

                <div class="img1">
                    <img src="images/DesmosAllMods.png" alt="DesmosAllMods">
                </div>

                <p>
                    Con todo esto explicado es hora de ver el método encargado de crea el mapa de altura en EarthMaker.
                </p>

                <div class="img1">
                    <img src="images/MethodCreateHightMap.png" alt="MethodCreateHightMap">
                </div>

                <p>
                    El resultado seria este, pero se ve muy aburrido no? Ahora mismo el mundo es únicamente piedra.
                </p>

                <div class="img1">
                    <img src="images/ResultHeightMap.png" alt="ResultHeightMap">
                </div>

                <p>
                    Que tal si añadimos un poco de color al mundo? 
                </p>
            </section>
        
            <section>
                <h2 id="Bloques">
                    <a href="#Bloques">Los bloques</a>
                    <a href="#Bloques" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>

                <p>
                    Para poner color al mundo necesitamos definir nuevos bloques para que no haya únicamente piedra.
                    <br><br>
                    Esta es la definición de un objeto bloque con el nombre del bloque y el tipo de malla como atributos del bloque. El objeto bloque también cuenta con un constructor que inicializa todos los atributos del objeto.
                </p>

                <div class="img1">
                    <img src="images/ClassBlock.png" alt="ClassBlock">
                </div>

                <p>
                    Para definir el nombre del bloque y el tipo de malla, usamos dos enumeraciones donde almacenamos todas las posibilidades.
                </p>

                <div class="img1">
                    <img src="images/EnumBlock.png" alt="EnumBlock">
                </div>

                <p>
                    A la hora de crear un bloque nuevo uso otra clase donde tengo unos bloques modelo. Gracias a esto, puedo hacer copias de estos bloques sin usar el constructor directamente.
                </p>

                <div class="img1">
                    <img src="images/ClassBlockType.png" alt="ClassBlockType">
                </div>
                
                <p>
                    Ahora es el momento de usar estos bloques. 
                </p>
            </section>

            <section>
                <h2 id="Population">
                    <a href="#Population">Population</a>
                    <a href="#Population" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>

                <p>
                    Para empezar una explicación de que significa Population, la traducción seria poblar y hace referencia para resumir a poner los bloques en el mundo.
                    <br><br>
                    De todo esto se encarga la clase Population. Esta clase se instancia una vez por cada nuevo chunk. Esta es la definición de la clase.
                </p>

                <div class="img1">
                    <img src="images/ClassPopulation.png" alt="ClassPopulation">
                </div>

                <p>
                    Para empezar con la Population añadimos 3 métodos al método Populate. StoneLayer, BedrockLayer, DirtGrassLayer. Para el ejemplo del terreno anterior el método StoneLayer ya existía, así que empezaremos por este primero.
                    <br><br>
                    Este método consiste en recorrer toda la array de bloques y parar en el momento llegas a la altura determinado por el heightMap.
                </p>

                <div class="img1">
                    <img src="images/MethodStoneLayer.png" alt="MethodStoneLayer">
                </div>

                <p>
                    Como todo el mundo sabe Minecraft permite al jugador romper bloques, lo cual podría llevar al jugador a caer al bacio si picase suficiente hacia abajo. Para evitarlo el juego cuenta con un bloque "indestructible" llamado bedrock. Así que he querido implementar algo parecido de ello se encarga el método BedrockLayer.
                    <br><br>
                    La bedrock se genera de manera aleatoria y por capas. Teniendo la capa de altura 0 un 100% de bloques de bedrock y decrementando en un 20% para conseguir 5 capas con cada vez menos bedrock.
                </p>

                <div class="img1">
                    <img src="images/MethodBedrockLayer.png" alt="MethodBedrockLayer">
                </div>

                <p>
                    Este seria el resultado.
                </p>

                <div class="img1">
                    <img src="images/ResultBedrockLayer.png" alt="ResultBedrockLayer">
                </div>

                <p>
                    Y por ultimo el método que realmente hace que tenga color el mundo. DirtGrassLayer. Este usa un sistema parecido al usado en BedrockLayer.
                    <br><br>
                    El método genera entre 2 y 3 bloques de tierra por debajo del de césped que siempre se genera.
                </p>

                <div class="img1">
                    <img src="images/MethodDirtGrassLayer.png" alt="MethodDirtGrassLayer">
                </div>

                <p>
                    Este seria el resultado.
                </p>

                <div class="img1">
                    <img src="images/ResultDirtGrassLayer.png" alt="ResultDirtGrassLayer">
                </div>
            </section>

            <section>
                <h2 id="ResultadoFinal">
                    <a href="#ResultadoFinal">Resultado final</a>
                    <a href="#ResultadoFinal" class="anchor">#</a>
                    <a href="#TableOfContent" class="anchor">^</a>
                </h2>

                <p>
                    Para terminar esta es una imagen del mismo terreno que se mostró dos secciones atrás, esta vez con todos los tipos de bloques en el mundo.
                </p>

                <div class="img1">
                    <img src="images/ResultPopulation.png" alt="ResultPopulation">
                </div>

                <p>
                    Con esto termina este post. Hay bastantes cosas que me gustaría añadir pero que por falta de tiempo me ha resultado imposible.
                    <br><br>
                    La primera de ellas seria la creación de biomas y la interpolación entre la altura y los bloques especificas de cada uno de dichos biomas.
                    <br><br>
                    Al igual que la vegetación, digo que el mundo tiene vida porque es de color verde pero una parte muy importante seria añadir arboles y plantas.
                    <br><br>
                    <a href="https://github.com/Weimil/EarthMakerLite/releases/tag/Release">El codigo en github.</a>
                </p>
            </section>
        </main>

        <footer>
            <div>
                <div id="ChangeLog">
                    25th Febrary 2022
                    Created the post.
                </div>
            </div>
        </footer>
    </body>
</html>